From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Ivan Pekov <ivan@mrivanplays.com>
Date: Tue, 24 Jan 2023 15:08:59 +0200
Subject: [PATCH] Fixes and improvements on entities


diff --git a/src/main/java/com/mrivanplays/multipaper/ChestBoatInventoryUpdatePacket.java b/src/main/java/com/mrivanplays/multipaper/ChestBoatInventoryUpdatePacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..65fc58b43ad469b499529bf44423224093b625f0
--- /dev/null
+++ b/src/main/java/com/mrivanplays/multipaper/ChestBoatInventoryUpdatePacket.java
@@ -0,0 +1,118 @@
+package com.mrivanplays.multipaper;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.vehicle.ChestBoat;
+import net.minecraft.world.item.ItemStack;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.externalserverprotocol.EntityRemovePacket;
+import puregero.multipaper.externalserverprotocol.ExternalServerPacket;
+
+public class ChestBoatInventoryUpdatePacket extends ExternalServerPacket {
+
+    private final String world;
+    private final UUID entityId;
+    private Map<Integer, CompoundTag> items;
+    private final boolean empty;
+
+    public ChestBoatInventoryUpdatePacket(ChestBoat entity) {
+        this.world = ((ServerLevel) entity.level).convertable.getLevelId();
+        this.entityId = entity.getUUID();
+
+        if (!entity.getItemStacks().isEmpty()) {
+            this.empty = false;
+            this.items = new HashMap<>();
+            for (int i = 0; i < 27; i++) {
+                CompoundTag nbt = new CompoundTag();
+                ItemStack item = entity.getItem(i);
+                if (item.isEmpty()) {
+                    continue;
+                }
+                nbt.putInt("MultiPaper.Slot", i);
+                item.save(nbt);
+            }
+        } else {
+            this.empty = true;
+        }
+    }
+
+    public ChestBoatInventoryUpdatePacket(FriendlyByteBuf in) {
+        this.world = in.readUtf();
+        this.entityId = in.readUUID();
+        this.empty = in.readBoolean();
+        if (!this.empty) {
+            int size = in.readInt();
+            this.items = new HashMap<>(size);
+            for (int i = 0; i < size; i++) {
+                CompoundTag nbt = in.readNbt();
+                int slot = nbt.getInt("MultiPaper.Slot");
+                nbt.remove("MultiPaper.Slot");
+                this.items.put(slot, nbt);
+            }
+        }
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            World bukkitWorld = Bukkit.getWorld(this.world);
+            if (bukkitWorld instanceof CraftWorld craftWorld) {
+                ServerLevel level = craftWorld.getHandle();
+                this.updateContents(level);
+            }
+        });
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(this.world);
+        out.writeUUID(this.entityId);
+        out.writeBoolean(this.empty);
+        if (!this.empty) {
+            out.writeInt(this.items.size());
+            for (CompoundTag nbt : this.items.values()) {
+                out.writeNbt(nbt);
+            }
+        }
+    }
+
+    private void updateContents(ServerLevel level) {
+        Entity.RemovalReason removalReason = EntityRemovePacket.removedEntities.get(this.entityId);
+        if (removalReason != null && removalReason.shouldDestroy()) {
+            return;
+        }
+
+        Entity entity = level.entityManager.knownUuids.get(this.entityId);
+        if (!(entity instanceof ChestBoat chestBoat)) {
+            return;
+        }
+
+        if (this.empty) {
+            for (int i = 0; i < 27; i++) {
+                chestBoat.removeItemNoUpdate(i);
+            }
+            return;
+        }
+
+        for (int i = 0; i < 27; i++) {
+            CompoundTag itemTag = this.items.get(i);
+            if (itemTag == null && chestBoat.getItem(i) != ItemStack.EMPTY) {
+                chestBoat.setItemNoSync(i, ItemStack.EMPTY);
+                continue;
+            }
+            if (itemTag == null) {
+                continue;
+            }
+            chestBoat.setItemNoSync(i, ItemStack.of(itemTag));
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index c7ea15ca0c6594e832d58ec4aed5c86d0d2052dd..7753621bda74d343333f4ee5444f36b4fbbcbadb 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -2837,7 +2837,11 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public void stopRiding(boolean suppressCancellation) {
         // Paper end
         if (this.vehicle != null) {
-            boolean wasControllingPassenger = MultiPaperEntitiesHandler.getControllingPassenger(this.vehicle) == this; // MultiPaper
+            // MultiPaper start - MrIvanPlays - better wasControllingPassenger check
+            var controllingPassenger = MultiPaperEntitiesHandler.getControllingPassenger(this.vehicle);
+            boolean wasControllingPassenger = controllingPassenger == this; // MultiPaper
+            wasControllingPassenger = !wasControllingPassenger ? controllingPassenger.getUUID().equals(this.getUUID()) : true;
+            // MultiPaper MrIvanPlays end
             Entity entity = this.vehicle;
 
             this.vehicle = null;
@@ -2845,9 +2849,9 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
 
             // MultiPaper start - inform other servers that the player is no longer riding the entity and hand them the entity's data
             LevelChunk chunk = level.getChunkIfLoaded(entity.blockPosition);
-            if (vehicle == null && MultiPaper.isRealPlayer(this) && wasControllingPassenger && !EntityRemovePacket.removedEntities.containsKey(entity.getRootVehicle().getUUID())) {
+            if (chunk != null && vehicle == null && MultiPaper.isRealPlayer(this) && wasControllingPassenger && !EntityRemovePacket.removedEntities.containsKey(entity.getRootVehicle().getUUID())) { // MultiPaper MrIvanPlays - do not call if the chunk is null
                 // Any server might now be controlling this vehicle
-                Set<ExternalServer> servers = new LinkedHashSet<>(chunk == null ? Collections.emptyList() : chunk.externalEntitiesSubscribers);
+                Set<ExternalServer> servers = new LinkedHashSet<>(chunk.externalEntitiesSubscribers); // MultiPaper MrIvanPlays - null check moved up
 
                 if (MultiPaperEntitiesHandler.getControllingPassenger(this.vehicle) instanceof ExternalPlayer newController) {
                     // Make sure we send the vehicle to the new controlling passenger, even if they don't have the chunk loaded
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/ChestBoat.java b/src/main/java/net/minecraft/world/entity/vehicle/ChestBoat.java
index ba14657c6911bfd54da6ee9e248b3a050455d68a..0b1711e196c6a39fb844ffca795deecc059b6d4f 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/ChestBoat.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/ChestBoat.java
@@ -153,19 +153,41 @@ public class ChestBoat extends Boat implements HasCustomInventoryScreen, Contain
 
     @Override
     public ItemStack removeItem(int slot, int amount) {
+        try { // MultiPaper - MrIvanPlays
         return this.removeChestVehicleItem(slot, amount);
+        } finally { // MultiPaper start - MrIvanPlays
+            this.sendUpdatePacket();
+        } // MultiPaper end - MrIvanPlays
     }
 
     @Override
     public ItemStack removeItemNoUpdate(int slot) {
+        try { // MultiPaper - MrIvanPlays
         return this.removeChestVehicleItemNoUpdate(slot);
+        } finally { // MultiPaper start - MrIvanPlays
+            this.sendUpdatePacket();
+        } // MultiPaper end - MrIvanPlays
     }
 
     @Override
     public void setItem(int slot, ItemStack stack) {
+        this.sendUpdatePacket(); // MultiPaper - MrIvanPlays
         this.setChestVehicleItem(slot, stack);
     }
 
+    // MultiPaper start - MrIvanPlays - sync inventory
+    private void sendUpdatePacket() {
+        net.minecraft.world.level.chunk.LevelChunk chunk = this.level.getChunkIfLoaded(this.blockPosition);
+        if (chunk != null) {
+            java.util.Set<puregero.multipaper.ExternalServer> servers = new java.util.HashSet<>(chunk.externalEntitiesSubscribers);
+            puregero.multipaper.MultiPaper.broadcastPacketToExternalServers(servers, () -> new com.mrivanplays.multipaper.ChestBoatInventoryUpdatePacket(this));
+        }
+    }
+    public void setItemNoSync(int slot, ItemStack item) {
+        this.setChestVehicleItem(slot, item);
+    }
+    // MultiPaper end - MrIvanPlays
+
     @Override
     public SlotAccess getSlot(int mappedIndex) {
         return this.getChestVehicleSlot(mappedIndex);
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
index 707374502a35ced453bc861a0a2cdba7ac766d4f..19c432e9252264a2efcd835211eb3ddfc430e85c 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
@@ -139,6 +139,7 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
             ListTag listTag = new ListTag();
             final java.util.Map<net.minecraft.world.entity.EntityType<?>, Integer> savedEntityCounts = new java.util.HashMap<>(); // Paper
             dataList.getEntities().forEach((entity) -> {
+                if (puregero.multipaper.externalserverprotocol.EntityRemovePacket.removedEntities.containsKey(entity.getUUID())) return; // MultiPaper - MrIvanPlays - do not store removed entities
                 // Paper start
                 final EntityType<?> entityType = entity.getType();
                 final int saveLimit = this.level.paperConfig().chunks.entityPerChunkSaveLimit.getOrDefault(entityType, -1);
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateNBTPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateNBTPacket.java
index 2b9772a0a9fa60794d27cdcb632e6d26f0dd32e5..3d13840e6378820740d47ab18ccb28f6dbb361fe 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateNBTPacket.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateNBTPacket.java
@@ -86,6 +86,7 @@ public class EntityUpdateNBTPacket extends ExternalServerPacket {
         }
 
         Entity entity = level.entityManager.knownUuids.get(uuid);
+        boolean loadedRecursive = false; // MrIvanPlays
 
         if (entity == null) {
             entity = EntityType.loadEntityRecursive(tag, level, entity2 -> {
@@ -99,6 +100,7 @@ public class EntityUpdateNBTPacket extends ExternalServerPacket {
                     return null;
                 }
             });
+            loadedRecursive = true; // MrIvanPlays
         } else if (entity instanceof ServerPlayer player) {
             new Exception("Tried to update the nbt of player " + player.getScoreboardName() + " to " + tag).printStackTrace();
         } else {
@@ -108,6 +110,7 @@ public class EntityUpdateNBTPacket extends ExternalServerPacket {
             }
         }
 
+        if (!loadedRecursive) { // MrIvanPlays
         if (tag.contains("Passengers", 9)) {
             ListTag nbttaglist = tag.getList("Passengers", 10);
 
@@ -120,6 +123,7 @@ public class EntityUpdateNBTPacket extends ExternalServerPacket {
                 }
             }
         }
+        } // MrIvanPlays
 
         if (entity instanceof Mob mob) mob.restoreLeashFromSave();
 
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index 5901037507fc498a45e1916ee97c39a3c6b4ca81..3663d7acdfa459eae3d97a0c253db05f7d87fecf 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -1,5 +1,6 @@
 package puregero.multipaper.externalserverprotocol;
 
+import com.mrivanplays.multipaper.ChestBoatInventoryUpdatePacket;
 import net.minecraft.network.FriendlyByteBuf;
 
 import java.util.ArrayList;
@@ -79,6 +80,7 @@ public class ExternalServerPacketSerializer {
         addPacket(GameEventPacket.class, GameEventPacket::new);
         addPacket(PistonMoveBlockStartPacket.class, PistonMoveBlockStartPacket::new);
         addPacket(PistonMoveBlockEndPacket.class, PistonMoveBlockEndPacket::new);
+        addPacket(ChestBoatInventoryUpdatePacket.class, ChestBoatInventoryUpdatePacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, Function<FriendlyByteBuf, ExternalServerPacket> deserializer) {
